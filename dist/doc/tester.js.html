<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pft/objects/tester.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: pft/objects/tester.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/** @namespace */
PFT.tester = {
    /**
     * property representing the global test timeout value in milliseconds.
     * this can be overridden for a specific test by passing a 'maxDuration'
     * option to the {@link PFT.tester.test} function
     */
    timeOutAfter: PFT.DEFAULT_TIMEOUT,

    /** @ignore */
    ready: true,

    /** @ignore */
    running: false,

    /** @ignore */
    inQueue: [],

    /**
     * property tracking the currently running task as index 0 and
     * any previously executed tasks as the subsequent indeces
     */
    outQueue: [],

    /** @ignore */
    _currentSuite: null,

    /** @ignore */
    remainingCount: 0,

    /** @ignore */
    globalStartTime: null,

    /**
     * enum property representing a suite type
     */
    SUITE: 0,

    /**
     * enum property representing a setup type
     */
    SETUP: 1,

    /**
     * enum property representing a test type
     */
    TEST: 2,

    /**
     * enum property representing a teardown type
     */
    TEARDOWN: 3,

    /** @ignore */
    _reset: function () {
        PFT.tester.running = false;
        PFT.tester.ready = true;
        PFT.tester.inQueue = [];
        PFT.tester.outQueue = [];
        PFT.tester.globalStartTime = null;
        PFT.tester.timeOutAfter = PFT.DEFAULT_TIMEOUT;
        PFT.tester._currentSuite = null;
        PFT.tester.remainingCount = 0;
    },

    /**
     * function will set the suite of any subsequent tests to
     * this suite name
     */
    suite: function (name, options) {
        PFT.tester.appendToExecutionQueue(name, PFT.tester.SUITE, undefined, function suite() {
            PFT.tester._currentSuite = name;
            PFT.logger.log(PFT.logger.TEST, "Suite: " + name);
            PFT.tester.onSuiteStarted({ suite: name });
            PFT.tester.done();
        });
    },

    /**
     * function will schedule the passed in {@link testCallback} for execution.
     * When the test is complete it MUST call {@link PFT.tester.done} to indicate
     * that the next step should proceed
     * @param {string} name - the name of the test
     * @param {Object} [options={}] - a set of options specific to this test
     * @param {Integer} [options.maxDuration] - the maximum amount of time this
     * test will be allowed to execute in milliseconds
     * @param {function} [options.setup] - a function to be called prior to execution
     * of this test. When complete a setup function MUST call {@link PFT.tester.done}
     * to indicate that the setup is complete
     * @param {Integer} [options.tearDown] - a function to be called after execution
     * of this test. When complete a tearDown function MUST call {@link PFT.tester.done}
     * to indicate that the tearDown is complete
     * @param {Object} [data=undefined] - an Object to be passed to the test upon
     * execution. This can be used for parameterization of tests.
     * @param {testCallback} callback - the function to execute as a test. when
     * executed this function will be passed three arguments, a PhantomJs.Webpage.Page,
     * a data object and a reference to the {@link PFT.tester.assert} object
     */
    test: function (name, options, data, callback) {
        if (arguments.length === 2) {
            callback = options;
            options = undefined;
        }
        if (!options) {
            options = {};
        }
        var maxDuration;
        if (options.maxDuration) {
            maxDuration = options.maxDuration;
        }

        if (options.setup) {
            PFT.tester.appendToExecutionQueue("Setup - " + name, PFT.tester.SETUP, data, function setup(data) {
                options.setup.call(this, data);
            }, maxDuration);
        }
        PFT.tester.remainingCount++;
        PFT.tester.appendToExecutionQueue(name, PFT.tester.TEST, data, function runTest(page, data, assert) {
            var msg = "Starting: '" + PFT.tester.outQueue[0].name + "'...";
            if (data) {
                msg += "\n\tData: " + JSON.stringify(data);
            }
            PFT.logger.log(PFT.logger.TEST, msg);
            PFT.tester.onTestStarted({ test: PFT.tester.outQueue[0] });
            callback.call(this, page, data, assert);
        }, maxDuration, PFT.tester._currentSuite);
        if (options.tearDown) {
            PFT.tester.appendToExecutionQueue("TearDown - " + name, PFT.tester.TEARDOWN, data, function tearDown(data) {
                options.tearDown.call(this, data);
            }, maxDuration);
        }
    },

    /** @ignore */
    appendToExecutionQueue: function (name, type, data, fn, maxDuration, suite) {
        PFT.tester.inQueue.push({
            fn: fn,
            type: type,
            name: name,
            data: data,
            passes: 0,
            failures: [],
            errors: [],
            maxDuration: maxDuration,
            suite: suite,
        });
    },

    /** @namespace */
    assert: {
        /**
         * function to test the value of a passed in boolean is true
         * and to signal a halt to the current test if it is not.
         * function will also call {@link PFT.tester.done} so that any
         * subsequent tests can continue. triggers the {@link PFT.tester.onAssertionFailure}
         * function call if passed in value is false
         * @param {boolean} value - the boolean value to be compared to 'true'
         * @param {string} message - a message to display describing the failure in the
         * case of a failed comparison. this message is referenced in the current test as well
         * as globally in {@link PFT.tester.failures}
         */
        isTrue: function (value, message) {
            if (!value) {
                var m = message || "expected 'true' but was 'false'";
                m = "'" + PFT.tester.outQueue[0].name + "'\n\t" + m;
                PFT.tester.outQueue[0].failures.push(m);
                PFT.tester.outQueue[0].halt = true;
                PFT.logger.log(PFT.logger.TEST, "Assert failed - " + m);
                PFT.tester.onAssertionFailure({ test: PFT.tester.outQueue[0], message: m });
                // halt execution, but continue with other tests
                throw m;
            } else {
                PFT.tester.outQueue[0].passes++;
            }
        },

        isFalse: function (value, message) {
            var m = message || "expected 'false' but was 'true'";
            PFT.tester.assert.isTrue(!value, message);
        },

        pass: function (message) {
            var m = message || PFT.tester.outQueue[0].name;
            PFT.logger.log(PFT.logger.TEST, "PASS: " + m);
            PFT.tester.assert.isTrue(true, message);
            PFT.tester.done();
        },

        fail: function (message) {
            var m = message || PFT.tester.outQueue[0].name;
            PFT.logger.log(PFT.logger.TEST, "FAIL: " + m, true);
            PFT.tester.assert.isTrue(false, message);
            PFT.tester.done();
        },
    },

    pass: function (message) {
        PFT.tester.assert.pass(message);
    },

    fail: function (message) {
        PFT.tester.assert.fail(message);
    },

    /**
     * function that will start the execution of all tests added through the
     * {@link PFT.tester.test} function. Calling this method while already
     * running has no side effects
     */
    start: function () {
        if (!PFT.tester.running) {
            PFT.tester.globalStartTime = new Date().getTime();
            PFT.tester.running = true;
            PFT.tester.executionLoop();
        }
    },

    /** @ignore */
    executionLoop: function () {
        var duration = (PFT.tester.outQueue[0] && PFT.tester.outQueue[0].maxDuration) ? PFT.tester.outQueue[0].maxDuration : PFT.tester.timeOutAfter;
        if (PFT.tester.outQueue[0] && PFT.tester.outQueue[0].startTime && (new Date().getTime() - PFT.tester.outQueue[0].startTime) >= duration) {
            var msg = "Test '" + PFT.tester.outQueue[0].name + "' exceeded timeout of " + duration;
            PFT.tester.outQueue[0].errors.push(msg);
            PFT.logger.log(PFT.logger.TEST, msg);
            PFT.tester.onTimeout({ test: PFT.tester.outQueue[0], message: msg });
            PFT.tester.done();
        }
        if (PFT.tester.inQueue.length > 0) {
            if (PFT.tester.ready && PFT.tester.running) {
                try {
                    PFT.tester.ready = false;
                    PFT.tester.outQueue.unshift(PFT.tester.inQueue.shift());
                    PFT.tester.outQueue[0].startTime = new Date().getTime();
                    if (PFT.tester.outQueue[0].type === PFT.tester.TEST) {
                        PFT.tester.outQueue[0].page = PFT.createPage();
                    }
                    PFT.tester.outQueue[0].data = PFT.tester.outQueue[0].data;
                    PFT.tester.outQueue[0].fn.call(this, PFT.tester.outQueue[0].page, PFT.tester.outQueue[0].data, PFT.tester.assert);
                } catch(e) {
                    phantom.onError(e);
                }
            }
        } else {
            if (PFT.tester.ready && PFT.tester.remainingCount &lt; 1) {
                PFT.tester.exit();
            }
        }

        if (PFT.tester.running) {
            setTimeout(PFT.tester.executionLoop, 10);
        }
    },

    /**
     * function to be called at the end of asynchronous test, setup and tearDown.
     * This indicates that the next scheduled item can be executed. Only call this
     * function when all tasks are complete within a {@link PFT.tester.test}
     */
    done: function () {
        if (PFT.tester.outQueue[0] && PFT.tester.outQueue[0].type === PFT.tester.TEST) {
            var duration = PFT.convertMsToHumanReadable(new Date().getTime() - PFT.tester.outQueue[0].startTime);
            PFT.tester.outQueue[0].duration = duration;
            var msg = "Completed: '" + PFT.tester.outQueue[0].name + "' in " + duration + " with " + PFT.tester.outQueue[0].passes + " passes, " +
                PFT.tester.outQueue[0].failures.length + " failures, " + PFT.tester.outQueue[0].errors.length + " errors.";
            PFT.logger.log(PFT.logger.TEST, msg);
        }
        PFT.tester.ready = true;
        if (PFT.tester.outQueue[0].type === PFT.tester.TEST) {
            PFT.tester.remainingCount--;
            PFT.tester.outQueue[0].page.close();
            PFT.tester.onTestCompleted({ test: PFT.tester.outQueue[0] });
        }
    },

    /**
     * function will halt the triggering of any additional tests following
     * completion of the existing task
     */
    stop: function () {
        PFT.tester.running = false;
    },

    /** @ignore */
    exit: function () {
        PFT.tester.stop();
        var duration = PFT.convertMsToHumanReadable(new Date().getTime() - PFT.tester.globalStartTime);

        var i,
            j,
            wroteFailures = false,
            wroteErrors = false,
            passes = 0,
            failures = 0,
            errors = 0,
            failuresMsg = "",
            errorsMsg = "";
        for (i=0; i&lt;PFT.tester.outQueue.length; i++) {
            passes += PFT.tester.outQueue[i].passes;
            failures += PFT.tester.outQueue[i].failures.length;
            errors += PFT.tester.outQueue[i].errors.length;
            for (j=0; j&lt;PFT.tester.outQueue[i].failures.length; j++) {
                var failure = PFT.tester.outQueue[i].failures[i];
                if (!wroteFailures) {
                    wroteFailures = true;
                    failuresMsg += "\nFAILURES:\n";
                }
                failuresMsg += "\t" + failure + "\n";
            }
            for (j=0; j&lt;PFT.tester.outQueue[i].errors.length; j++) {
                var error = PFT.tester.outQueue[i].errors[j];
                if (!wroteErrors) {
                    wroteErrors = true;
                    errorsMsg += "\nERRORS:\n";
                }
                errorsMsg += "\t" + error + "\n";
            }
        }

        var msg = "Completed all tests in " + duration + " with " + passes + " passes, " +
            failures + " failures, " + errors + " errors.\n";
        msg += failuresMsg;
        msg += errorsMsg;
        PFT.logger.log(PFT.logger.TEST, msg);
        PFT.tester.onExit({ message: msg });
        var exitCode = errors + failures;
        // ensure message gets out before exiting
        setTimeout(function () {
            phantom.exit(exitCode);
        }, 1000);
    },

    /**
     * function hook that is called when a new test is started
     */
    onTestStarted: function (details) {
        // hook for testing
    },

    /**
     * function hook that is called when a new suite is started
     */
    onSuiteStarted: function (details) {
        // hook for testing
    },

    /**
     * function hook that is called when a test completes. this
     * includes anything resulting in {@link PFT.tester.done}
     * being called
     */
    onTestCompleted: function (details) {
        // hook for testing
    },

    /**
     * function hook that is called when the underlying page
     * experiences an error
     */
    onPageError: function (details) {
        // hook for testing
    },

    /**
     * function hook that is called when there is a test error
     */
    onError: function (details) {
        // hook for testing
    },

    /**
     * function hook that is called when a test times out
     */
    onTimeout: function (details) {
        // hook for testing
    },

    /**
     * function hook that is called when an assertion fails
     */
    onAssertionFailure: function (details) {
        // hook for testing
    },

    /**
     * function hook that is called when program exits
     */
    onExit: function (details) {

    },
};

/**
 * This callback is executed as a test and will only be run when
 * any previous test has completed. If Setup and TearDown methods
 * are specified in the test options those will be run before and
 * after the test
 * @callback testCallback
 * @param {PhantomJs.Webpage.Page} page - a PhantomJs Page object for use in
 * testing
 * @param {Object} data - the data object passed to the {@link PFT.tester.test}
 * function
 * @param {PFT.tester.assert} assert - a convenience object for
 * accessing {@link PFT.tester.assert}
 */
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="PFT.BasePage.html">BasePage</a></li></ul><h3>Namespaces</h3><ul><li><a href="PFT.html">PFT</a></li><li><a href="PFT.logger.html">logger</a></li><li><a href="PFT.tester.html">tester</a></li><li><a href="PFT.tester.assert.html">assert</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Wed Jan 28 2015 21:33:06 GMT-0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
